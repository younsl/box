mod grouper;
mod models;
mod output;
mod parser;

use anyhow::{Context, Result};
use clap::Parser;
use dialoguer::Confirm;
use std::fs;
use std::path::PathBuf;

const VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Parser, Debug)]
#[command(
    name = "promdrop",
    version = VERSION,
    about = "Generates Prometheus relabel configs to drop unused metrics",
    long_about = "PromDrop analyzes prometheus-metrics.json (e.g., generated by Mimirtool),\n\
                  identifies unused metrics (additional_metric_counts),\n\
                  and generates Prometheus metric_relabel_configs YAML file(s) to drop them per job.\n\n\
                  It also generates .txt files listing the metrics to be dropped for each job."
)]
struct Cli {
    /// Input prometheus-metrics.json file path
    #[arg(short = 'f', long = "file", value_name = "FILE")]
    input_file: PathBuf,

    /// Output directory for .txt files
    #[arg(
        short = 't',
        long = "txt-output-dir",
        value_name = "DIR",
        default_value = "unused"
    )]
    txt_output_dir: PathBuf,

    /// Output file path for combined YAML
    #[arg(
        short = 'o',
        long = "output",
        value_name = "FILE",
        default_value = "combined_relabel_configs.yaml"
    )]
    output_file: PathBuf,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    // Ensure output directory exists
    fs::create_dir_all(&cli.txt_output_dir).with_context(|| {
        format!(
            "Failed to create output directory: {}",
            cli.txt_output_dir.display()
        )
    })?;

    println!(
        "[Info] Reading input JSON file: '{}'...",
        cli.input_file.display()
    );

    // Parse metrics
    let parsed = parser::parse_metrics_file(&cli.input_file)?;

    if parsed.summary_data.is_empty() {
        println!(
            "[Info] No unused metrics data found to process (check additional_metric_counts)."
        );
        return Ok(());
    }

    println!(
        "[Info] Found unused metrics for {} jobs.",
        parsed.summary_data.len()
    );

    // Print summary table
    println!("\n--- Unused Metric Summary ---");
    output::print_summary_table(&parsed.summary_data);
    println!("----------------------------");

    // Generate summary file
    let summary_path = cli.txt_output_dir.join("summary.txt");
    println!(
        "[Info] Attempting to generate summary file: '{}'...",
        summary_path.display()
    );
    output::generate_summary_file(
        &cli.txt_output_dir,
        &parsed.summary_data,
        cli.input_file.to_str().unwrap_or("unknown"),
    )?;

    // User confirmation
    let confirmed = Confirm::new()
        .with_prompt("Do you want to generate relabel config files?")
        .default(true)
        .interact()?;

    if !confirmed {
        println!("\n[Info] Operation cancelled by user.");
        return Ok(());
    }

    // Generate output files
    println!("\n[Info] Starting .txt and YAML file generation...");
    println!(
        "[Info] Output directory for .txt files: '{}'",
        cli.txt_output_dir.canonicalize()?.display()
    );
    println!(
        "[Info] Output file for combined YAML: '{}'",
        cli.output_file
            .canonicalize()
            .unwrap_or(cli.output_file.clone())
            .display()
    );

    // Generate .txt files for each job
    for item in &parsed.summary_data {
        let job_name = &item.job_name;
        if let Some(metrics) = parsed.job_metrics_map.get(job_name) {
            output::generate_txt_file(&cli.txt_output_dir, job_name, metrics)?;
        }
    }

    // Generate combined YAML file
    let processed_count = output::generate_yaml_file(
        &cli.output_file,
        &parsed.job_metrics_map,
        &parsed.summary_data,
        parsed.total_unique_metrics,
    )?;

    println!(
        "[Complete] Processed {} jobs and generated YAML configuration for {} unique unused metrics.",
        processed_count, parsed.total_unique_metrics
    );

    Ok(())
}
